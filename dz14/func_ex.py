# Взаимодействие функций и изменяемых типов данных

# Пропишем функцию которая будет увеличивать значение каждого элемента в списке на единицу
def increment_list(list_obj):
    # Если не прописать копирование списка внутри функции, то мы будем менять тот изначальный список
    # Который передали в качестве агрумента в функцию
    # list_obj = list_obj.copy()
    for i in range(len(list_obj)):
        list_obj[i] += 1
    return list_obj


li = [1, 5, 8, 12, 11]
print(increment_list(li.copy()))
print(li)
# Изменяемые типы данных при передаче в функцию необходимо копировать, чтобы не менять исходные коллекции


# Параметры принимаемые по умолчанию
# Если значением по умолчанию прописать пустой список, то в случае многократного вызова данной функции без аргументов
# Мы будем получать список наполненный элементами а не список с добавленной единичкой
def foo(li=[]):
    li.append(1)
    return li
# Дело в том что список определенный в параметре ссылается на одну и ту же ячейку памяти, соответственно, каждый
# вызов функции добавляет элемент к тому же самому списку

# Для того чтобы этого избежать, значением по умолчанию ставится любое значение, чаще всего None(отсутвие значения)
# Чтобы в процессе внутри функции осуществлять создание пустого списка
def foo_right(li=None):
    if li == None:
        li = []
    li.append(1)
    return li

print(foo())
print(foo([10, 12]))
print(foo())
print(foo())
print(foo())

print(foo_right([3, 5, 2]))
print(foo_right())
print(foo_right())
print(foo_right())
print(foo_right())
