# Методы поиска подстроки в строке

st = "hello  in world"
str2 = "__init__"
str_num = "123"
str_num_n = "123f"
# Оператор принадлежности in работает примерно так же как и со списками, только ищет не исключительно один элемент
# из набора, а совокупность
print("hello in" in st)

# Метод count возвращает количество вхождений символа или подстроки в указаную строку
# строка_в_которой_ищем.count("символ или набор символов которые ищем")
print(st.count('o', 5)) # так же существуют доп аргументы которые позволяют ограничивать диапазон поиска
# (стартовый и конечный индексы)
print(st.count("world"))
print(st.count(' '))

# методы find и index ищут индекс первого вхождения подстроки или символа
print(st.index('in'))# так же существуют доп аргументы которые позволяют ограничивать диапазон поиска
print(st.find('ind'))# так же существуют доп аргументы которые позволяют ограничивать диапазон поиска
# Разница между методоми лишь в возвращаемом значении если элемент найти не удалось
# Метод index возвращает исключение, а find возвращает -1
# Подобные методы, разница лишь в стороне с которой начинается поиск
print(st.rindex('l'))
print(st.rfind('o'))

# Методы проверки начала и окончания строк
# Метод startswith возвращает True если строка начинается с определенной подстроки и False в обратном случае
print(str2.startswith("__"))
# Метод endswith возвращает True если строка заканчивается определенной подстрокой и False в обратном случае
print(str2.endswith('!'))

# Проверка скрок
# метод isdigit() - возвращает тру если вся строка состоит из цифровых символов False если есть хоть один не цифровой
print(str_num.isdigit())
print(str_num_n.isdigit())

# Метод isalnum - возвращает true только кода строка состоит исключительно из цифр и букв
# (пробельные символы не являются корректными) в противном случае False
print(st.isalnum())
print(str_num_n.isalnum())

#isalpha() - возвращает TRue если строка состоит только из буквенных символов
print(st.isalpha())
print(str_num_n.isalpha())

# Проверка наличия в строке символов соответствующих кодировке ascii (соответственно латиница, цифры, знаки препинания)
print(st.isascii())

# Методы форматирования строк
str1 = "1234"
str2 = "+11"
str3 = '13584554'
# Метод center - заполняет строку до определенной длины элементами с каждой стороны (символами которые укажем
# в качестве второго параметра) по умолчанию если не ставить второй параметр, это пробелы
print(str1.center(5, '*'))
print(str2.center(6, '*'))
print(str3.center(6, '*'))
# Заполняем строку символами до определенной длины ljust - добавляет элементы справа rjust слева, заполнитель
# можно указать вторым параметром
print(str2.ljust(6, '0'))
print(str2.rjust(6, '0'))
# zfill похож на rjust (когда в нем используется в качестве второго параметра '0') Но когда в строке есть минус
# или плюс вначале то лучше использовать zfill
print(str2.zfill(6))

#Метод replace принимает в качестве параметров два обязательных аргумента(обе строки) старая последовательность и новая
# на которую небходимо произвести замену, необязательный аргумент count(третий аргумент) указываетт количество замен
string1 = "dog is walk, and dog is not a cow"

print(string1.replace('dog', 'cats'))
print(string1.replace('dog', 'cats', 1))

#strip осуществляет удаление пробельных символов вначале и в конце строки
inp = "          ./12345    /."
print(inp.strip())
# Так же в качестве параметра можно указать в качестве строки набор символов которые необходимо
# убирать с каждого края строки
inp = inp.strip(' ./') # существуют так же методы для удаления элементов только с одного края lstrip и rstrip


# inp = int(inp)
print(inp)

# Метод позволяющий разделить строку на список из строк
print(st)
# Если нет агрументов то разделяет по пробельному символу
print(st.split())
# Можно указать собственный разделитель
print(st.split('  '))
st = st.split()
print(st)
# Соединить строки из списка можно следующим образом
# Сперва указывается в качестве строки элемент или подстрока которая будет стоять между строками из списка
# У нее вызывается метод join(передается список)
print(', '.join(st))
