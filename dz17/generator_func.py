# Генераторные функции
# ran = range(1, 5)
# ran = iter(ran)
# print(next(ran))
# print(next(ran))
# print(next(ran))

def func(num):
    return num
    num += 1


# При замене ключевого слова return на слово yield полностью меняется механика работы функции
def func_gener(num):
    # При вызове next функция отрабатывает до следующего опереатора yield
    yield num # возвращает значение которое после него указанно и запоминает позицию в функции
    # При последующем вызове next осуществляется выполнение всех последующих инструкции до следующего yield и так далее
    num += 1
    yield num
    print("Инструкций больше нет")
    # yield "Пусто"


num = func(12)
print(num)
# Результатом работы данной функции будет объект генератор
num2 = func_gener(20)
print(num2)
# Значения из этого объекта будут получаться только при вызове функции next с данным генератором в качестве аргумента
print(next(num2))
print(next(num2))
# Если вызовов next больше чем yield в функции то возвращает stopIteration(так же как и с обычным итератором)
print(next(num2))
# Или же при помощи цикла фор
# А так же при использовании функции при помощи которых генератор приводится к коллекции
# print(tuple(num2))