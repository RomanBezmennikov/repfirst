from time import time


# Преимущество итератора над обычным списком
# Вызывая итератор от диапазона 0-9 мы получаем всего один объект с элементом в котором находится ссылка
# на следующий элемент
a = iter(range(10))
g = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
print(next(a))
print(next(a))
print(next(a))
print(next(a))

# Это то что происходит на каждой итерации цикла фор под капотом
i = (next(a))
print(i)
#
for i in a:
    print(i)

# Сравнение списка и объекта итератора
# Сгенерируем список из 1000 элементов
li = [i for i in range(1000)]
# Создадим итератор из 1000 элементов
it = iter(range(1000))
print(li)
print(it)
# НЕ смотря на определенные недостатки итератора (напимер невозможность повторного итерирования)
# Присутствуют такие крупные достоинства как малый объем занимаемой памяти так как значения подготавливаются на лету
print(li.__sizeof__(), it.__sizeof__())


# Также замерим время работы
# Замеряем время начала работы генератора
t1 = time()
li = [i for i in range(1000000)]
# Замерям разницу во времени после отработки генератора и до отработки
print(time() - t1)

t2 = time()
it = iter(range(1000000000000))
print(time() - t2)
print(li.__sizeof__(), it.__sizeof__())